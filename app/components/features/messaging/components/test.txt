'use client';

import { useState, useEffect, useRef, useCallback } from 'react';
import Image from 'next/image';
import { Send, Loader2, Paperclip, X, FileIcon, ImageIcon } from 'lucide-react';
import { useSocket } from '@/app/components/providers/socket-provider';
import { useMessages } from '../hooks';
import { MessageBubble } from './MessageBubble';
import { Button } from '@/app/components/ui/button';
import type { Message } from '../types';
import { cn } from '@/lib/utils';
import { useUploadThing } from '@/app/api/uploadthing/route';
import { toast } from 'sonner';

interface ChatInterfaceProps {
  matchId: string;
  currentUserId: string;
  otherUserId: string;
  otherUserImage?: string | null;
  otherUserName?: string;
  currentUserImage?: string | null;
  currentUserName?: string;
  isUnmatched?: boolean;
}

// Group consecutive messages from the same sender within 10 seconds
function groupMessages(messages: Message[]): Array<{ message: Message; group: Message[] }> {
  const grouped: Array<{ message: Message; group: Message[] }> = [];
  const TIME_THRESHOLD = 10000; // 10 seconds

  for (let i = 0; i < messages.length; i++) {
    const current = messages[i];
    const group: Message[] = [current];

    // Look ahead for messages from the same sender within the time threshold
    let j = i + 1;
    while (j < messages.length) {
      const next = messages[j];
      const timeDiff = new Date(next.createdAt).getTime() - new Date(current.createdAt).getTime();

      // Group if same sender and within time threshold
      if (next.senderId === current.senderId && timeDiff <= TIME_THRESHOLD) {
        group.push(next);
        j++;
      } else {
        break;
      }
    }

    grouped.push({ message: current, group });
    i = j - 1; // Skip the messages we've already grouped
  }

  return grouped;
}

export function ChatInterface({
  matchId,
  currentUserId,
  otherUserId,
  otherUserImage,
  otherUserName,
  currentUserImage,
  currentUserName,
  isUnmatched = false,
}: ChatInterfaceProps) {
  const { socket, isConnected } = useSocket();
  const { data: initialMessages = [], isLoading } = useMessages(matchId);
  const [messages, setMessages] = useState<Message[]>([]);
  const [newMessage, setNewMessage] = useState('');
  const [isSending, setIsSending] = useState(false);
  const [isTyping, setIsTyping] = useState(false);
  const [selectedFiles, setSelectedFiles] = useState<File[]>([]);
  const [filePreviews, setFilePreviews] = useState<
    { file: File; preview?: string }[]
  >([]);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const typingTimeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);
  const markedAsReadRef = useRef<Set<string>>(new Set<string>());
  const fileInputRef = useRef<HTMLInputElement>(null);
  const initializedMatchRef = useRef<string | null>(null);
  const roomJoinedRef = useRef<string | null>(null);
  const currentMatchIdRef = useRef<string>(matchId);

  const { startUpload, isUploading } = useUploadThing('messageAttachment');

  // Keep currentMatchIdRef in sync
  useEffect(() => {
    currentMatchIdRef.current = matchId;
  }, [matchId]);

  // Group messages for display
  const groupedMessages = groupMessages(messages);

  // Debug: Log grouped messages
  console.log('Rendering ChatInterface with', messages.length, 'messages,', groupedMessages.length, 'groups');

  const formatFileSize = (bytes: number): string => {
    if (bytes < 1024 * 1024) {
      return `${(bytes / 1024).toFixed(2)} KB`;
    }
    return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
  };

  // Initialize messages when matchId changes or initial messages load
  useEffect(() => {
    if (matchId !== initializedMatchRef.current) {
      console.log('Match changed, resetting messages for:', matchId);
      setMessages(initialMessages);
      markedAsReadRef.current.clear();
      initializedMatchRef.current = matchId;
    } else if (!isLoading && initialMessages.length > 0 && messages.length === 0) {
      console.log('Loading initial messages for:', matchId);
      setMessages(initialMessages);
    }
  }, [matchId, initialMessages, isLoading, messages.length]);

  // Mark a message as read (helper function)
  const markMessageAsRead = useCallback(
    (messageId: string) => {
      if (!socket || !isConnected || markedAsReadRef.current.has(messageId))
        return;

      markedAsReadRef.current.add(messageId);
      socket.emit('message:read', { messageId });
    },
    [socket, isConnected]
  );

  // Mark initial unread messages as read when they load
  useEffect(() => {
    if (!socket || !isConnected || initialMessages.length === 0) return;

    initialMessages.forEach((msg) => {
      if (!msg.readAt && msg.senderId !== currentUserId) {
        markMessageAsRead(msg.id);
      }
    });
  }, [socket, isConnected, initialMessages, currentUserId, markMessageAsRead]);

  // Socket connection and event handlers
  useEffect(() => {
    if (!socket || !isConnected) {
      console.log('Socket not connected or not available', { socket: !!socket, isConnected });
      roomJoinedRef.current = null;
      return;
    }

    console.log('Joining match room:', matchId);
    socket.emit('match:join', { matchId });
    roomJoinedRef.current = matchId;

    const handleNewMessage = (message: {
      id: string;
      matchId: string;
      senderId: string;
      content: string;
      type: 'TEXT' | 'IMAGE' | 'FILE';
      fileUrl?: string | null;
      fileKey?: string | null;
      fileName?: string | null;
      fileSize?: number | null;
      fileType?: string | null;
      createdAt: string;
    }) => {
      console.log('Received message:new event for match', message.matchId, 'current match:', currentMatchIdRef.current, 'message:', message);

      // Use a ref check to avoid stale closure values
      if (message.matchId !== currentMatchIdRef.current) {
        console.log('Message matchId does not match current matchId, ignoring');
        return;
      }

      setMessages((prev) => {
        // Check if message already exists (by ID)
        const exists = prev.some((m) => m.id === message.id);
        if (exists) {
          console.log('Message already exists, skipping', message.id);
          return prev;
        }

        // Add the new message
        console.log('Adding new message to state', message.id);
        const newMessages = [...prev, { ...message, readAt: null }];
        console.log('Messages state after adding:', newMessages.length, 'messages');
        return newMessages;
      });

      // Mark new message as read if it's from other user
      if (message.senderId !== currentUserId) {
        markMessageAsRead(message.id);
      }
    };

    const handleMessageRead = (data: { messageId: string; readAt: string }) => {
      setMessages((prev) =>
        prev.map((msg) =>
          msg.id === data.messageId ? { ...msg, readAt: data.readAt } : msg
        )
      );
    };

    const handleTypingStart = (data: { userId: string; matchId: string }) => {
      if (data.matchId === matchId && data.userId === otherUserId) {
        setIsTyping(true);
      }
    };

    const handleTypingStop = (data: { userId: string; matchId: string }) => {
      if (data.matchId === matchId && data.userId === otherUserId) {
        setIsTyping(false);
      }
    };

    // Remove all previous listeners before adding new ones to prevent duplicates
    socket.off('message:new');
    socket.off('message:read');
    socket.off('typing:start');
    socket.off('typing:stop');

    socket.on('message:new', handleNewMessage);
    socket.on('message:read', handleMessageRead);
    socket.on('typing:start', handleTypingStart);
    socket.on('typing:stop', handleTypingStop);

    console.log('Socket event listeners registered for match:', matchId);

    return () => {
      console.log('Cleaning up socket listeners and leaving match room:', matchId);
      socket.off('message:new', handleNewMessage);
      socket.off('message:read', handleMessageRead);
      socket.off('typing:start', handleTypingStart);
      socket.off('typing:stop', handleTypingStop);
      socket.emit('match:leave', { matchId });
    };
  }, [socket, isConnected, matchId, currentUserId, otherUserId, markMessageAsRead]);

  // Debug: Log when messages state changes
  useEffect(() => {
    console.log('Messages state updated, total messages:', messages.length);
    console.log('Current messages:', messages.map(m => ({ id: m.id, content: m.content })));
  }, [messages]);

  // Auto-scroll to bottom when messages change
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  const handleInputChange = (value: string) => {
    setNewMessage(value);

    if (!socket || !isConnected) return;

    if (value.trim()) {
      socket.emit('typing:start', { matchId });

      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
      }

      typingTimeoutRef.current = setTimeout(() => {
        socket.emit('typing:stop', { matchId });
      }, 2000);
    } else {
      socket.emit('typing:stop', { matchId });
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
      }
    }
  };

  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = Array.from(e.target.files || []);
    if (files.length === 0) return;

    // Validate each file
    const validFiles: File[] = [];
    for (const file of files) {
      // Check file size (max 32MB for videos, 16MB for PDFs, 8MB for images)
      const maxSize = file.type.startsWith('video/')
        ? 32 * 1024 * 1024
        : file.type === 'application/pdf'
        ? 16 * 1024 * 1024
        : 8 * 1024 * 1024;

      if (file.size > maxSize) {
        toast.error(
          `${file.name} is too large. Maximum size is ${
            maxSize / (1024 * 1024)
          }MB`
        );
        continue;
      }

      validFiles.push(file);
    }

    if (validFiles.length === 0) return;

    // Append to existing files instead of replacing
    setSelectedFiles((prev) => [...prev, ...validFiles]);

    // Create previews for images
    const previews: { file: File; preview?: string }[] = [];
    let loadedPreviews = 0;
    const imageFilesCount = validFiles.filter((f) =>
      f.type.startsWith('image/')
    ).length;

    validFiles.forEach((file) => {
      if (file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onloadend = () => {
          previews.push({ file, preview: reader.result as string });
          loadedPreviews++;
          if (loadedPreviews === imageFilesCount) {
            // Add non-image files
            validFiles.forEach((f) => {
              if (!f.type.startsWith('image/')) {
                previews.push({ file: f });
              }
            });
            // Append to existing previews
            setFilePreviews((prev) => [...prev, ...previews]);
          }
        };
        reader.readAsDataURL(file);
      } else {
        previews.push({ file });
      }
    });

    // If no images, set previews immediately
    if (validFiles.every((f) => !f.type.startsWith('image/'))) {
      setFilePreviews((prev) => [...prev, ...previews]);
    }

    // Clear the file input so the same file can be selected again
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  const handleRemoveFile = (fileToRemove?: File) => {
    if (fileToRemove) {
      // Remove specific file
      setSelectedFiles((prev) => prev.filter((f) => f !== fileToRemove));
      setFilePreviews((prev) => prev.filter((p) => p.file !== fileToRemove));
    } else {
      // Remove all files
      setSelectedFiles([]);
      setFilePreviews([]);
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    }
  };

  const handleSendMessage = async (e: React.FormEvent) => {
    e.preventDefault();

    if (isSending || !socket || !isConnected || isUnmatched) return;

    // Ensure we've joined the room before sending
    if (roomJoinedRef.current !== matchId) {
      console.log('Room not joined yet, joining now');
      socket.emit('match:join', { matchId });
      roomJoinedRef.current = matchId;
      // Small delay to ensure room join is processed
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    // Check if we have either a message or files
    if (!newMessage.trim() && selectedFiles.length === 0) return;

    const messageContent = newMessage.trim();
    setIsSending(true);

    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }
    socket.emit('typing:stop', { matchId });

    try {
      // If there are files, upload and send each as a separate message
      if (selectedFiles.length > 0) {
        for (let i = 0; i < selectedFiles.length; i++) {
          const file = selectedFiles[i];

          try {
            console.log('Uploading file:', file.name);
            const uploadResult = await startUpload([file]);
            console.log('Upload result:', uploadResult);

            if (uploadResult && uploadResult[0]) {
              const fileData = {
                url: uploadResult[0].url,
                key: uploadResult[0].key,
                name: uploadResult[0].name,
                size: uploadResult[0].size,
                type: uploadResult[0].type,
              };

              console.log('Sending message with file:', fileData);
              // Send file message (include text content only with the first file)
              socket.emit('message:send', {
                matchId,
                content: i === 0 && messageContent ? messageContent : '',
                file: fileData,
              });
            } else {
              console.error('Upload failed for file:', file.name);
              toast.error(`Failed to upload ${file.name}`);
            }
          } catch (uploadError) {
            console.error('Error uploading file:', file.name, uploadError);
            toast.error(`Failed to upload ${file.name}`);
          }
        }
      } else if (messageContent) {
        // Send text-only message
        console.log('Emitting message:send event', { matchId, content: messageContent });
        socket.emit('message:send', {
          matchId,
          content: messageContent,
        });
      }

      // Clear form
      setNewMessage('');
      handleRemoveFile();
    } catch (error) {
      console.error('Failed to send message:', error);
      toast.error('Failed to send message');
    } finally {
      setIsSending(false);
    }
  };

  if (isLoading) {
    return (
      <div className='flex-1 flex items-center justify-center'>
        <Loader2 className='w-8 h-8 animate-spin text-primary-main' />
      </div>
    );
  }

  return (
    <div className='flex flex-col h-full overflow-hidden custom-scrollbar'>
      <div className='flex-1 overflow-y-auto p-4 space-y-2'>
        {messages.length === 0 ? (
          <div className='flex items-center justify-center h-full'>
            <p className='text-text-muted text-center'>
              No messages yet. Start the conversation!
            </p>
          </div>
        ) : (
          groupedMessages.map(({ message, group }) => (
            <MessageBubble
              key={message.id}
              message={message}
              isOwnMessage={message.senderId === currentUserId}
              senderImage={otherUserImage}
              senderName={otherUserName}
              currentUserImage={currentUserImage}
              currentUserName={currentUserName}
              groupedMessages={group.length > 1 ? group : undefined}
            />
          ))
        )}
        {isTyping && (
          <div className='flex justify-start mb-4 gap-2 items-end'>
            <div className='w-8 h-8 rounded-full overflow-hidden bg-bg-input shrink-0 relative'>
              {otherUserImage ? (
                <Image
                  src={otherUserImage}
                  alt={otherUserName || 'User'}
                  fill
                  className='object-cover'
                  sizes='32px'
                />
              ) : (
                <div className='w-full h-full flex items-center justify-center bg-primary-main text-primary-text text-sm font-semibold'>
                  {otherUserName?.charAt(0).toUpperCase() || '?'}
                </div>
              )}
            </div>
            <div className='bg-bg-card text-text-muted border border-border-main rounded-2xl px-4 py-2 rounded-bl-sm'>
              <div className='flex gap-1'>
                <span className='w-2 h-2 bg-text-muted rounded-full animate-bounce'></span>
                <span
                  className='w-2 h-2 bg-text-muted rounded-full animate-bounce'
                  style={{ animationDelay: '0.2s' }}
                ></span>
                <span
                  className='w-2 h-2 bg-text-muted rounded-full animate-bounce'
                  style={{ animationDelay: '0.4s' }}
                ></span>
              </div>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <div className='border-t border-border-main bg-bg-card p-4'>
        {isUnmatched ? (
          <div className='text-center py-3 px-4 bg-bg-hover border border-border-main rounded-lg'>
            <p className='text-sm text-text-muted'>
              You&apos;ve unmatched with this person. You can view chat history
              but cannot send new messages.
            </p>
          </div>
        ) : (
          <>
            {!isConnected && (
              <div className='mb-2 text-center text-sm text-warning'>
                Connecting to server...
              </div>
            )}

            {/* File Previews */}
            {filePreviews.length > 0 && (
              <div className='mb-3'>
                <div className='flex flex-wrap gap-2 mb-2'>
                  {filePreviews.map((filePreview, index) => (
                    <div key={index} className='relative group'>
                      {filePreview.preview ? (
                        <div className='w-32 h-32 rounded-lg overflow-hidden bg-bg-input relative border-2 border-border-main'>
                          <Image
                            src={filePreview.preview}
                            alt='Preview'
                            fill
                            className='object-cover'
                          />
                          <button
                            type='button'
                            onClick={() => handleRemoveFile(filePreview.file)}
                            className='absolute top-1 right-1 bg-bg-main/80 rounded-full p-1 text-text-muted hover:text-error transition-colors opacity-0 group-hover:opacity-100 cursor-pointer'
                          >
                            <X className='w-4 h-4' />
                          </button>
                        </div>
                      ) : (
                        <div className='p-3 bg-bg-hover border border-border-main rounded-lg'>
                          <div className='flex items-center gap-3 min-w-[200px]'>
                            <div className='w-12 h-12 rounded-lg bg-primary-main/10 dark:bg-primary-text/10 flex items-center justify-center'>
                              <FileIcon className='w-6 h-6 text-primary-main dark:text-primary-text' />
                            </div>
                            <div className='flex-1 min-w-0'>
                              <p className='text-sm font-medium text-text-heading truncate'>
                                {filePreview.file.name}
                              </p>
                              <p className='text-xs text-text-muted'>
                                {formatFileSize(filePreview.file.size)}
                              </p>
                            </div>
                            <button
                              type='button'
                              onClick={() => handleRemoveFile(filePreview.file)}
                              className='text-text-muted hover:text-error transition-colors p-1'
                            >
                              <X className='w-5 h-5' />
                            </button>
                          </div>
                        </div>
                      )}
                    </div>
                  ))}
                </div>
                {filePreviews.length > 1 && (
                  <button
                    type='button'
                    onClick={() => handleRemoveFile()}
                    className='text-sm text-error hover:underline'
                  >
                    Remove all ({filePreviews.length} files)
                  </button>
                )}
              </div>
            )}

            <form onSubmit={handleSendMessage} className='flex gap-2'>
              <input
                ref={fileInputRef}
                type='file'
                accept='image/*,application/pdf,video/*'
                onChange={handleFileSelect}
                className='hidden'
                multiple
              />
              <Button
                type='button'
                onClick={() => fileInputRef.current?.click()}
                disabled={isSending || !isConnected || isUploading}
                variant='ghost'
                className='rounded-full w-10 h-10 p-0 hover:bg-primary-main dark:hover:bg-secondary-main cursor-pointer'
              >
                <Paperclip className='w-5 h-5' />
              </Button>
              <input
                type='text'
                value={newMessage}
                onChange={(e) => handleInputChange(e.target.value)}
                placeholder='Type a message...'
                className={cn(
                  'flex-1 px-4 py-2 rounded-full border dark:border-secondary-main bg-bg-input text-text-body',
                  'border-border-input focus:outline-none focus:border-primary-main',
                  'placeholder:text-text-muted'
                )}
                maxLength={5000}
                disabled={isSending || !isConnected}
              />
              <Button
                type='submit'
                disabled={
                  (!newMessage.trim() && selectedFiles.length === 0) ||
                  isSending ||
                  !isConnected ||
                  isUploading
                }
                className='rounded-full w-10 h-10 p-0 bg-primary-main text-primary-text hover:bg-primary-hover dark:bg-secondary-main dark:text-secondary-text dark:hover:bg-secondary-hover cursor-pointer'
              >
                {isSending || isUploading ? (
                  <Loader2 className='w-5 h-5 animate-spin' />
                ) : (
                  <Send className='w-5 h-5' />
                )}
              </Button>
            </form>
          </>
        )}
      </div>
    </div>
  );
}
